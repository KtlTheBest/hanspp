
// CUP specification for Cflat.
// Hans de Nivelle

import java_cup.runtime.* ; 

parser code {:  
   public void syntax_error( Symbol next )
   {
      System. out. println( "Syntax Error at position " + 
                               ( next. left + 1 ) + "/" + next. right +
                               " for lookahead " + 
                               sym. terminalNames [ next. sym ] +
                               " with attribute " + next. value );
   }
:}

// Terminals (tokens returned by the tokenizer): 

terminal     ast.Bool         BOOLCONST;
terminal     ast.Char         CHARCONST;
terminal     ast.Integer      INTEGERCONST;
terminal     ast.Double       DOUBLECONST;
terminal     ast.String       STRINGCONST;
terminal     ast.Pointer      POINTERCONST; 
terminal     ast.Identifier   IDENTIFIER;

terminal          VOID, BOOL, CHAR, INTEGER, DOUBLE, POINTER, ARRAY;
terminal          IF, THEN, ELSE, WHILE, DO, PRINT, RETURN;
terminal          FUNCTION, STRUCTDEF, CONSTANT;
terminal          BEGIN, END;
terminal          LPAR, RPAR, LSQPAR, RSQPAR, COMMA, DOT, ARROW;
terminal          COLON, SEMICOLON;
terminal          ASSIGN;
   // For the operators, I use python names as much as possible: 
terminal          QUESTION, OR, AND, NOT;
terminal          EQ, NE, LT, GT, LE, GE;
terminal          ADD, SUB, MUL, TRUEDIV, MODULO;
terminal          AMPERSAND, PLUSPLUS, MINUSMINUS;

non terminal Program        Prog ; 
non terminal java.util.ArrayList< type.Field > Decllist, Decllist2;
non terminal type.Field                        Decl;
non terminal type.Type                         Type;
non terminal ast.Tree                          Stat;
non terminal ast.Tree       Expr, Expr1, Expr2, Expr3, Expr4, Expr5, Expr6;
non terminal ast.Tree       Expr7, Expr8, Expr9, Expr10, Expr11, Expr12; 
non terminal java.util.ArrayList< ast.Tree >   Exprlist ;

Prog ::=   Prog:p CONSTANT IDENTIFIER:i ASSIGN BOOLCONST:b SEMICOLON
              {: p. addconstant( i. id, b ); RESULT = p; :} 

         | Prog:p CONSTANT IDENTIFIER:i ASSIGN CHARCONST:c SEMICOLON 
              {: p. addconstant( i. id, c ); RESULT = p; :}
         | Prog:p CONSTANT IDENTIFIER:i ASSIGN INTEGERCONST: j SEMICOLON
              {: p. addconstant( i. id, j ); RESULT = p; :}
         | Prog:p STRUCTDEF IDENTIFIER:i ASSIGN 
                  LPAR Decllist : lst RPAR SEMICOLON
            {: p. addstruct( i. id, lst ); RESULT = p; :}
         | Prog:p FUNCTION IDENTIFIER:i LPAR Decllist : params RPAR COLON 
           Type: rettype Stat: body
           {: p. addfunction( i. id, params, rettype, body ); 
              RESULT = p; :} 
         |
            {: RESULT = new Program( ); :}
         ; 

Decllist ::=
         {: RESULT = new java.util.ArrayList< type.Field > ( ); :}
         |
         Decllist2 : lst 
         {: RESULT = lst; :}
         ;

Decllist2 ::= Decl : d 
                     {: RESULT = new java.util.ArrayList< type.Field > ( );
                        RESULT. add( d ); :} 
          |
             Decllist2 : lst COMMA Decl : d 
                {: RESULT = lst; RESULT. add( d ); :} 
          ;

Decl ::= IDENTIFIER:id COLON Type:tp 
         {:
             RESULT = new type.Field( id. id, tp );  
         :}
         ;

Type ::=   VOID {: RESULT = new type.Void( ); :}
         | BOOL {: RESULT = new type.Bool( ); :}
         ;

Stat  ::=  IF Expr : cond THEN Stat : body 
              {: RESULT = new ast.Apply( "[if]", cond, body ); :}
         |
           IF Expr :cond THEN Stat:s1 ELSE Stat:s2 
              {: RESULT = new ast.Apply( "[if]", cond, s1, s2 ); :} 
         ;

Expr ::= Expr2 : e1 ASSIGN Expr2: e2 {: RESULT = new ast.Apply("=", e1, e2); :}
    | Expr2 : e2 {: RESULT = e2; :}
    ;

Expr2 ::= Expr3 : Cond QUESTION Expr3 : True COLON Expr3 : False 
      {: RESULT = new ast.Apply("??", Cond, True, False); :}
      | Expr3 : e3 {: RESULT = e3; :}
      ;

Expr3 ::= Exrp3 : cond1 OR Expr4 : cond2 {: RESULT = new ast.Apply("??", cond1, true, cond2); :}
    | Expr4 : e4 {: RESULT = e4; :}
    ;

Expr4 ::= Exrp4 : cond1 AND Expr5 : cond2 {: RESULT = new ast.Apply("??", cond1, cond2, false); :}
    | Expr5 : e5 {: RESULT = e5; :}
    ;

Expr5 ::= NOT Expr5 : e5 {: RESULT = new ast.Apply("??", e5, false, true); :}
    | Expr6 : e6 {: RESULT = e6; :}
    ;

Expr6 ::= Expr7 : e1 EQ Expr7 : e2 {: RESULT = new ast.Apply("==", e1, e2); :}
    | Expr7 : e1 NEQ Expr7 : e2    {: RESULT = new ast.Apply("!=", e1, e2); :}
    | Expr7 : e1 LT Expr7 : e2     {: RESULT = new ast.Apply("<", e1, e2); :}
    | Expr7 : e1 GT Expr7 : e2     {: RESULT = new ast.Apply(">", e1, e2); :}
    | Expr7 : e1 LE Expr7 : e2     {: RESULT = new ast.Apply("<=", e1, e2); :}
    | Expr7 : e1 GE Expr7 : e2     {: RESULT = new ast.Apply(">=", e1, e2); :}
    | Expr7 : e7                   {: RESULT = e7; :}
    ;

Expr7 ::= Expr7 : e1 ADD Expr8 : e2 {: RESULT = new ast.Apply("+", e1, e2); :}
    | Expr7 : e1 SUB Expr8 : e2 {: RESULT = new ast.Apply("-", e1, e2); :}
    | Expr8 : e8 {: RESULT = e8; :}
    ;

Expr8 ::= Expr8 : e1 MUL Expr9 : e2 {: RESULT = new ast.Apply("*", e1, e2); :}
    | Expr8 : e1 TRUEDIV Expr9 : e2 {: RESULT = new ast.Apply("/", e1, e2); :}
    | Expr8 : e1 MODULO Expr9 : e2 {: RESULT = new ast.Apply("%", e1, e2); :}
    | Expr9 : e9 {: RESULT = e9; :}
    ;

Exrp9 ::= MINUS Expr9 : e9 {: RESULT = new ast.Apply("-u", e9); :}
    | Expr10 : e10 {: RESULT = e10; :}
    ;

Expr10 ::= POINTER Expr10 : e10 {: RESULT = new ast.Apply("*", e10); :}
    | AMPERSAND Expr10 : e10 {: RESULT = new ast.Apply("&", e10); :}
    | Expr11 : e11 {: RESULT = e11; :}
    ;

Expr11 ::= PLUSPLUS Expr12 : e12 {: RESULT = new ast.Apply("ppx", e12); :}
    | MINUSMINUS Expr12 : e12 {: RESULT = new ast.Apply("mmx", e12); :}
    | Expr12 : e12 {: RESULT = e12; :}
    ;

Expr12 ::= Expr12 : e12 PLUSPLUS       {: RESULT = new ast.Apply("xpp", e12); :}
    | Expr12 : e12 MINUSMINUS          {: RESULT = new ast.Apply("xmm", e12); :}
    | Expr12 : e12 DOT IDENTIFIER : id {: RESULT = new ast.Select(id.toString(), e12); :}
    | Expr12 : e12 ARROW IDENTIFIER : id {: RESULT = new ast.Select(id.toString(), new ast.Apply("*", e12)); :}
    | Expr12 : e12 LSQPAR Expr : e RSQPAR {: RESULT = new ast.Apply("*", new ast.Apply("+", e12, e)); :}
    | IDENTIFIER : id {: RESULT = id; :}
    | IDENTIFIER : id LPAR Exprlist : lst RPAR {: RESULT = new ast.Apply(id.toString(), lst); :}
    | BOOLCONST : boolConst {: RESULT = boolConst; :}
    | CHARCONST : charConst {: RESULT = charConst; :}
    | INTEGERCONST : intConst {: RESULT = intConst; :}
    | DOUBLECONST : doubleConst {: RESULT = doubleConst; :}
    ;

Exprlist ::= Exprlist2 : lst {: RESULT = lst; :}
    | {: RESULT = new java.util.Arraylist <ast.Tree> (); :}
    ;

Exprlist2 ::= Expr : e {: RESULT = e; :}
    | Exprlist : lst COMMA Expr : e {: lst.add(e); RESULT = lst; :}
    ;

